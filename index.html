<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Football Match Organisation</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    <!-- Add Montserrat font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
</head>
<body>
    <div class="layout-container">
        <div class="main-content">
            <div class="site-title">
                <h1>Football Match Organisation</h1>
                <p>This site is a platform for those who want to organize and join football matches.</p>
                <noscript>
                    <p>JavaScript must be enabled to view matches.</p>
                </noscript>
            </div>

            <div class="new-match">
                <a href="create_match.html" class="dynamic-button">Create New Match</a>
            </div>

            <!-- Container for dynamically loading matches from the database -->
            <div id="matches-container">
                <!-- This will dynamically load matches -->
            </div>
        </div>

        <div class="sidebar">
            <div id="next-match-countdown" class="countdown">
                <h3>Next Match</h3>
                <div class="countdown-number">
                    <div>
                        <span id="days">00</span>
                        <div class="time-label">days</div>
                    </div>
                    <div>
                        <span id="hours">00</span>
                        <div class="time-label">hours</div>
                    </div>
                    <div>
                        <span id="minutes">00</span>
                        <div class="time-label">minutes</div>
                    </div>
                </div>
                <div id="next-match-info"></div>
            </div>
        </div>
    </div>

    <script>
    // Replace these with your actual Supabase credentials
    const SUPABASE_URL = 'https://cqmtrzgvtvlxobeyuquu.supabase.co'; // Your Supabase URL
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxbXRyemd2dHZseG9iZXl1cXV1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgxNzQ1MDUsImV4cCI6MjA2Mzc1MDUwNX0.FoB2vZZWMmR2o5-imFN1ijAdRxTr-R1ykXwOtYNCD3I'; // Your Supabase Anon Key

    // Initialize Supabase client
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    /**
     * Fetches matches from the database and displays them on the page.
     */
    async function fetchMatches() {
        const matchesContainer = document.getElementById('matches-container');
        matchesContainer.innerHTML = '<p>Loading matches...</p>';

        let { data: matches, error } = await supabase
            .from('matches')
            .select('*')
            .order(['match_date', 'match_time'], { ascending: true });

        if (error) {
            matchesContainer.innerHTML = '<p>Could not load matches.</p>';
            return;
        }

        matchesContainer.innerHTML = '';
        for (const match of matches) {
            const matchElement = document.createElement('div');
            matchElement.className = 'match-card';
            matchElement.innerHTML = `
                <h3>${match.title}</h3>
                <p><strong>Date:</strong> ${new Date(match.match_date).toLocaleDateString('en-GB')}</p>
                <p><strong>Time:</strong> ${match.match_time.substring(0, 5)}</p>
                <p><strong>Location:</strong> ${match.location}</p>
                <p><strong>Description:</strong> ${match.description || ''}</p>
                <div class="participants-list">
                    <div style="margin-bottom:8px;">
                        <strong>Participants/Quota:</strong>
                        <span class="participant-count" data-max-players="${match.max_players}">${match.current_players}</span>
                        / ${match.max_players}
                    </div>
                    <ul id="participants-${match.id}">Loading...</ul>
                </div>
                <button class="join-match-btn" 
                        data-match-id="${match.id}"
                        ${match.current_players >= match.max_players ? 'disabled' : ''}>
                    ${match.current_players >= match.max_players ? 'Match Full' : 'Join Match'}
                </button>
                <div class="discussion-panel">
                    <div class="discussion-title">${match.title} - Discussion</div>
                    <label class="comment-image-label">
                        <span class="attach-icon">ðŸ“Ž</span>
                        <input type="file" accept="image/*" class="comment-image" style="display:none;" />
                    </label>
                    <input type="text" placeholder="Your name" class="comment-username" />
                    <textarea placeholder="Write a comment..." class="comment-text"></textarea>
                    <button class="comment-submit-btn">Send</button>
                    <ul class="comment-list"></ul>
                </div>
            `;
            matchesContainer.appendChild(matchElement);

            // Store button a variable to be able to hide/show it
            const joinButton = matchElement.querySelector('.join-match-btn');
            joinButton.onclick = () => showJoinMatchForm(match.id, joinButton);
            fetchParticipants(match.id);
            setupDiscussionPanel(matchElement, match.id);
        }
        updateCountdown(matches);
    }

    /**
     * Shows an inline form for joining a match.
     * @param {number} matchId - The ID of the match to join.
     * @param {HTMLElement} buttonElement - The "Join Match" button element.
     */
    function showJoinMatchForm(matchId, buttonElement) {
        // Hide the original "Join Match" button
        buttonElement.style.display = 'none';

        // Create a container for the inline form
        const formContainer = document.createElement('div');
        formContainer.className = 'inline-join-form-container';

        // Create input field
        const inputField = document.createElement('input');
        inputField.type = 'text';
        inputField.placeholder = 'Enter your name';
        inputField.className = 'inline-join-input';
        formContainer.appendChild(inputField);

        // Create "Confirm Join" button
        const confirmButton = document.createElement('button');
        confirmButton.textContent = 'Confirm Join';
        confirmButton.className = 'inline-confirm-button';
        confirmButton.onclick = () => {
            const participantName = inputField.value;
            addParticipantToMatch(matchId, participantName);
            // Remove the form and show the original button
            formContainer.remove();
            buttonElement.style.display = ''; // Show the original button
        };
        formContainer.appendChild(confirmButton);

        // Create "Cancel" button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.className = 'inline-cancel-button'; // Add a class for styling
        cancelButton.onclick = () => {
            // Remove the form and show the original button
            formContainer.remove();
            buttonElement.style.display = ''; // Show the original button
        };
        formContainer.appendChild(cancelButton);

        // Insert the form container after the hidden button
        buttonElement.parentNode.insertBefore(formContainer, buttonElement.nextSibling);
    }

    /**
     * Fetches participants for a specific match and updates the participant list in the UI.
     * @param {number} matchId - The ID of the match to fetch participants for.
     */
    async function fetchParticipants(matchId) {
        const participantsList = document.getElementById(`participants-${matchId}`);
        if (!participantsList) return;

        const { data: participants, error } = await supabase
            .from('match_participants')
            .select('*')
            .eq('match_id', matchId)
            .order('id', { ascending: true });

        if (error) {
            participantsList.innerHTML = '<li>Could not load participants</li>';
            return;
        }

        // Update participant count and button state in the UI
        const matchCard = participantsList.closest('.match-card');
        if (matchCard) {
            const countElem = matchCard.querySelector('.participant-count');
            if (countElem) {
                countElem.textContent = participants ? participants.length : 0;
            }
            
            const joinButton = matchCard.querySelector('.join-match-btn');
            const maxPlayers = parseInt(matchCard.querySelector('.participant-count').dataset.maxPlayers);
            
            // Update button state
            if (participants.length >= maxPlayers) {
                joinButton.disabled = true;
                joinButton.classList.add('disabled');
                joinButton.textContent = 'Match Full';
            } else {
                joinButton.disabled = false;
                joinButton.classList.remove('disabled');
                joinButton.textContent = 'Join Match';
            }
        }

        // Update participants list with delete buttons
        participantsList.innerHTML = participants && participants.length > 0
            ? participants.map(p => `
                <li>
                    ${p.participant_name}
                    <button class="delete-participant" data-id="${p.id}">
                        Delete
                    </button>
                </li>`).join('')
            : '<li>No participants yet</li>';

        // Add event listeners to delete buttons
        participantsList.querySelectorAll('.delete-participant').forEach(button => {
            button.onclick = () => removeParticipant(button.dataset.id, matchId);
        });
    }

    // Add participant

    /**
     * Updates the countdown timer for the next match.
     * @param {Array} matches - List of matches sorted by date and time.
     */
    let timerInterval = null;

    async function updateCountdown(matches) {
        const countdownElement = document.getElementById('next-match-countdown');
        const nextMatchInfo = document.getElementById('next-match-info');

        // Only get future matches
        const now = new Date();
        const futureMatches = matches.filter(m => new Date(`${m.match_date}T${m.match_time}`) > now);

        if (!futureMatches || futureMatches.length === 0) {
            countdownElement.querySelector('h3').textContent = 'Next Match';
            nextMatchInfo.innerHTML = '<p>No upcoming matches.</p>';
            document.getElementById('days').textContent = '00';
            document.getElementById('hours').textContent = '00';
            document.getElementById('minutes').textContent = '00';
            if (timerInterval) clearInterval(timerInterval);
            return;
        }

        // Find the closest upcoming match
        futureMatches.sort((a, b) => new Date(`${a.match_date}T${a.match_time}`) - new Date(`${b.match_date}T${b.match_time}`));
        const nextMatch = futureMatches[0];
        const matchDate = new Date(`${nextMatch.match_date}T${nextMatch.match_time}`);

        nextMatchInfo.innerHTML = `
            <p>${nextMatch.title}</p>
            <p>${matchDate.toLocaleDateString('en-GB')} - ${nextMatch.match_time.substring(0, 5)}</p>
        `;

        if (timerInterval) clearInterval(timerInterval);

        function updateTimer() {
            const now = new Date();
            const distance = matchDate - now;

            if (distance < 0) {
                clearInterval(timerInterval);
                countdownElement.querySelector('h3').textContent = 'Next Match';
                nextMatchInfo.innerHTML = '<p>The match has started!</p>';
                document.getElementById('days').textContent = '00';
                document.getElementById('hours').textContent = '00';
                document.getElementById('minutes').textContent = '00';
                return;
            }

            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));

            document.getElementById('days').textContent = String(days).padStart(2, '0');
            document.getElementById('hours').textContent = String(hours).padStart(2, '0');
            document.getElementById('minutes').textContent = String(minutes).padStart(2, '0');
        }

        updateTimer();
        timerInterval = setInterval(updateTimer, 1000);
    }

    /**
     * Adds a participant to a match after validating input and checking availability.
     * @param {number} matchId - The ID of the match to join.
     * @param {string} participantName - The name of the participant.
     */
    async function addParticipantToMatch(matchId, participantName) {
        if (!participantName || participantName.trim() === '') {
            alert("Please enter a valid name.");
            return;
        }

        try {
            // Case-insensitive check for existing name
            const { data: existingParticipants, error: checkError } = await supabase
                .from('match_participants')
                .select('participant_name')
                .eq('match_id', matchId);

            const nameExists = existingParticipants?.some(p => 
                p.participant_name.localeCompare(participantName.trim(), undefined, { sensitivity: 'accent' }) === 0
            );

            if (nameExists) {
                alert('You have already joined this match with this name!');
                return;
            }

            // Check if the match is full
            const { data: currentMatch, error: fetchMatchError } = await supabase
                .from('matches')
                .select('current_players, max_players')
                .eq('id', matchId)
                .single();

            if (fetchMatchError) throw fetchMatchError;

            const { data: currentParticipants, error: fetchParticipantsError } = await supabase
                .from('match_participants')
                .select('id', { count: 'exact' })
                .eq('match_id', matchId);

            if (fetchParticipantsError) throw fetchParticipantsError;

            const actualParticipantCount = currentParticipants ? currentParticipants.count : 0;

            if (actualParticipantCount >= currentMatch.max_players) {
                alert('Sorry, this match became full while you were trying to join!');
                fetchMatches();
                return;
            }

            // Add participant
            const { error: participantInsertError } = await supabase
                .from('match_participants')
                .insert([{ 
                    match_id: matchId, 
                    participant_name: participantName.trim() 
                }]);

            if (participantInsertError) throw participantInsertError;

            // Update UI
            await fetchParticipants(matchId);
            alert(`You have joined the match as ${participantName.trim()}!`);

        } catch (error) {
            console.error('Error adding participant:', error);
            alert('An error occurred while adding the participant.');
        }
    }

    /**
     * Removes a participant from a match and updates the UI.
     * @param {number} participantId - The ID of the participant to remove.
     * @param {number} matchId - The ID of the match the participant belongs to.
     */
    async function removeParticipant(participantId, matchId) {
        if (!confirm('Are you sure you want to delete this participant?')) {
            return;
        }

        try {
            const { error } = await supabase
                .from('match_participants')
                .delete()
                .eq('id', participantId);

            if (error) throw error;

            // Update UI
            await fetchParticipants(matchId);
            alert('Participant deleted successfully!');

        } catch (error) {
            console.error('Error removing participant:', error);
            alert('An error occurred while deleting the participant.');
        }
    }

    // Initialize the page by fetching matches
    document.addEventListener('DOMContentLoaded', fetchMatches);
    // Storage iÃ§in klasÃ¶r adÄ±
const COMMENTS_IMAGES_FOLDER = 'match-comments-images';

// YorumlarÄ± Ã§ek ve listele
const commentsCache = new Map();
let commentSubscriptions = new Map();

async function fetchComments(matchId, container) {
  const listEl = container.querySelector('.comment-list');
  listEl.innerHTML = 'Loading comments...';

  // Check cache first
  if (commentsCache.has(matchId)) {
    const cachedComments = commentsCache.get(matchId);
    listEl.innerHTML = cachedComments.length
      ? cachedComments.map(c => `
        <li>
          <strong>${c.username || 'Anonymous'}</strong>: ${c.comment}
          ${c.image_url ? `<img src="${c.image_url}" alt="comment image" />` : ''}
        </li>
      `).join('')
      : '<li>No comments yet</li>';
    return;
  }

  let { data: comments, error } = await supabase
    .from('match_comments')
    .select('*')
    .eq('match_id', matchId)
    .order('created_at', { ascending: true });

  if (error) {
    console.error('Error fetching comments:', error);
    listEl.innerHTML = '<li>Unable to load comments due to a network issue or invalid match ID. Please try again later.</li>';
    return;
  }

  // Cache the comments
  commentsCache.set(matchId, comments);

  listEl.innerHTML = comments.length
    ? comments.map(c => `
      <li>
        <strong>${c.username || 'Anonymous'}</strong>: ${c.comment}
        ${c.image_url ? `<img src="${c.image_url}" alt="comment image" />` : ''}
      </li>
    `).join('')
    : '<li>No comments yet</li>';
}

// Yorum gÃ¶nderme iÅŸlemi
async function submitComment(matchId, container) {
  const usernameInput = container.querySelector('.comment-username');
  const commentInput = container.querySelector('.comment-text');
  const imageInput = container.querySelector('.comment-image');
  
  const username = usernameInput.value.trim();
  const comment = commentInput.value.trim();
  const file = imageInput.files[0];

  // Add name validation
  if (!username) {
    alert('Please enter your name.');
    usernameInput.focus();
    return;
  }

  if (!comment) {
    alert('Please enter a comment.');
    commentInput.focus();
    return;
  }

  let imageUrl = null;

  if (file) {
    try {
      const fileExt = file.name.split('.').pop();
      const fileName = `${matchId}/${Date.now()}.${fileExt}`;
      
      const sendBtn = container.querySelector('.comment-submit-btn');
      sendBtn.disabled = true;
      sendBtn.textContent = 'Uploading...';
      sendBtn.classList.add('uploading');
      
      // Upload file to Supabase Storage
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('match-comments-images')
        .upload(fileName, file, {
          cacheControl: '3600',
          upsert: false,
          contentType: file.type
        });

      if (uploadError) {
        console.error('Upload error:', uploadError);
        throw new Error(`Upload failed: ${uploadError.message}`);
      }

      // Get public URL
      const { data: urlData } = supabase.storage
        .from('match-comments-images')
        .getPublicUrl(fileName);

      if (!urlData?.publicUrl) {
        throw new Error('Failed to get public URL');
      }

      imageUrl = urlData.publicUrl;
      
      // Show success state
      sendBtn.textContent = 'âœ” Uploaded!';
      sendBtn.classList.add('upload-success');
      
    } catch (error) {
      alert(`Image upload failed: ${error.message}`);
      console.error('Upload error details:', error);
      return;
    } finally {
      const sendBtn = container.querySelector('.comment-submit-btn');
      sendBtn.disabled = false;
      setTimeout(() => {
        sendBtn.textContent = 'Send';
        sendBtn.classList.remove('uploading', 'upload-success');
      }, 1200);
    }
  }
  
  // Validate match_id before saving the comment
  const { data: matchExists, error: matchError } = await supabase
    .from('matches')
    .select('id')
    .eq('id', matchId)
    .single();

  if (matchError || !matchExists) {
    alert('Invalid match ID. Please try again.');
    return;
  }

  // Yorum kaydet
  try {
    const { error: insertError } = await supabase
      .from('match_comments')
      .insert([{
        match_id: matchId,
        username: username || null,
        comment,
        image_url: imageUrl,
      }]);

    if (insertError) throw insertError;

    // Clear input fields
    usernameInput.value = '';
    commentInput.value = '';
    imageInput.value = '';

    // No need to manually fetch comments here
    // The subscription will handle updating the UI
    
  } catch (error) {
    console.error('Error submitting comment:', error);
    alert('Failed to save comment: ' + error.message);
  }
}

// MaÃ§ kartÄ± yÃ¼klendiÄŸinde event listener ekle
function setupDiscussionPanel(matchElement, matchId) {
  const container = matchElement.querySelector('.discussion-panel');
  const sendBtn = container.querySelector('.comment-submit-btn');
  sendBtn.onclick = () => submitComment(matchId, container);
  
  // Initial fetch
  fetchComments(matchId, container);
  
  // Setup real-time subscription
  if (!commentSubscriptions.has(matchId)) {
      const subscription = supabase
          .channel(`match_comments_${matchId}`)
          .on('postgres_changes', {
              event: '*',
              schema: 'public',
              table: 'match_comments',
              filter: `match_id=eq.${matchId}`
          }, async (payload) => {
              // Refresh comments when changes occur
              await fetchComments(matchId, container);
          })
          .subscribe();
          
      commentSubscriptions.set(matchId, subscription);
  }
}

// Add cleanup function to remove subscriptions when leaving the page
window.addEventListener('beforeunload', () => {
    for (let [matchId, subscription] of commentSubscriptions) {
        subscription.unsubscribe();
    }
    commentSubscriptions.clear();
});
    
    </script>
    <a href="create_match.html" class="floating-button" title="Create New Match">ï¼‹</a>

    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <script>
      AOS.init();
    </script>
</body>
</html>
